# 17강. 동적 할당된 객체

## 동적 메모리 할당 및 해제

- 동적 메모리 할당
    - 프로그래머가 원하는 순간에, 원하는 크기의 메모리를 할당 받는 방법
        - new 연산자 사용
- 동적 메모리 할당 해제
    - 프로그래머가 원하는 순간에 더이상 필요 없는 동적 할당된 메모리의 할당 해제
        - delete 연산자 사용
        - 단일 변수/객체와 배열의 할당 해제 방법이 다름!
- 메모리를 할당하는 방식에는 크게3가지가 있다.
    - 지역 변수 할당을 위한 자동 할당
    - 전역 변수 할당을 위한 정적 할당
    - 사용자가 원하는 순간에 원하는 크기 만큼의 메모리를 할당 받아서 사용하는 동적 할당
- 지역 변수 할당을 위한 자동 할당이 가장 많이 사용된다.
- 지역적으로 선언되어지는 메모리 공간은 지역 안에서만 유효하고 그 지역을 벗어나면 사용할 수 없기 때문에 일반적으로 어떤 함수 안에서 선언되어진 데이터는 다른 함수에게 전달하기 위해서 그 값을 복사해서 전달한다라든가 또 함수 안에서 지역적으로 선언되어지는 변수는 호출 쪽으로 값을 복사해서 반환해 주는 처리가 필요했다(주소에 의한 전달, 포인터에 의한 전달 제외).

## 동적할당/해제 연산자

```cpp
base_type* p-var = new base_type;
delete p-var;
```

- 동적 메모리 할당하는 좀더 안전한 방법 제공
    - 동적 할당에 필요한 크기를 자동으로 할당
    - 할당된 영역에 대해 지정한 자료형의 포인터를 반환
    - 동적 할당된 객체를 초기화 가능
    - 라이브러리 헤더 <cstdlib> 포함 불필요

## 동적 메모리 할당

- new 연산자
    - 힙 영역에 저장 영역을 할당
    - 할당 영역의 포인터(주소)를 넘겨줌
        - 메모리 할당에 실패하면 널 포인터를 넘겨줌
    - 단 하나의 인자(할당될 항목의 타입)을 받음
- 동적 할당된 1차원 배열
    
    ```cpp
    base_type* p-var = new base_type[size];
    ```
    
    - 동적 할당 배열의 초기화는 불가능
    - base_type의 데이터에서 size 갯수 만큼의 메모리 영역이 할당되게 된다.
    - 해당 배열의 시작 주소 값을 전달해 준다.

## 동적 할당된 메모리 해제

- delete 연산자
    - new 연산자로 할당 받은 메모리를 해제
- 동적 할당된 메모리 해제
    
    ```cpp
    delete p-var;
    ```
    
    - p-var가 가리키고 있는 힙 영역의 데이터가 해제된다.
- 동적 할당된 배열의 해제
    
    ```cpp
    delete [] p-var;
    ```
    
    - 배열에 해당 데이터를 해제하게 되면 포인터 변수가 가리키고 있는 배열의 처음부터 연속적으로 할당된 데이터를 해제해 주게 된다.
    - 배열을 해재할 때 [] 안에 배열의 갯수를 명시할 필요 없음
    - 해당 포인터 변수가 가리키고 있는 배열을 알아서 삭제해 주고 있다.
    - 즉 배열이 선언될 때 해당 포인터 변수가 가리키고 있는 배열의 갯수를 이미 알고 있다.

## 동적 할당의 사용

- 배열을 동적으로 할당
    - 배열의 크기를 정할 수 있음
    - 배열의 크기를 변경하는 효과를 가질 수 있음
        - 새 배열을 할당 후 기존 배열을 대체
    - 어떤 함수 안에 배열을 만들고 원하는 크기의 배열을 만들어서 함수 호출 측에 전달을 할 때는 동적 할당하는 수밖에 없음
- 클래스 객체를 동적으로 할당
    - 함수 안에서 객체를 만들어 호출 측으로 반환 시
        - 반환 값 복사에 따른 메모리 조작을 줄이기 위해 동적할당된 클래스 객체의 주소를 반환
        - 기본 자료형 변수를 반환하는 경우엔 복사양이 많지 않기에 동적할당 사용 이점이 없음
    - 클래스 타입의 포인터 배열에 요소 할당 위해
    - 아주 큰 배열이 존재하더라도 미리 모든 객체에 대한 데이터를 배열에 할당하는 것이 아닌 필요한 시점에 할당을 해서 메모리를 효과적으로 사용할 수 있게 된다.
- 함수 안에서 데이터를 생성 후 해당 데이터를 값 복사 없이 전달하는 방법으로 사용 가능
- 힙에 생성된 데이터를 여러 스택 메모리에서 활용하기 위함

## 동적 할당된 객체

- new 연산자: 동적 할당된 객체를 초기화 가능
    - obj_type* p-var = new obj_type;
    - obj_type* p-var = new obj_type();
    - obj_type* p-var = new obj_type(iVal);
        - 생성자를 호출하여(초기화) 동적 할당
- delete 연산자: 할당 받은 메모리를 해제
    - delete p-var;

```cpp
Complex* pCom;
pCom = new Comlex;
```

- **동적 할당된 객체는 반드시 포인터 변수로 받아야 한다(매우 중요!).**

## C++에서 객체 생성 방법들

- 지역적으로 선언
    - 일반 지역변수와 같은 특징을 지님
    
    ```cpp
    Complex c1;
    Complex c2(0, 0); // 지역 변수를 생성할 때도 초기화 함수 호출 가능
    c2.ShowComplex(); // 멤버 참조 연산자를 통해서 함수 호출
    ```
    
- 동적 생성
    - 포인터 변수를 통해 간접 참조하여 접근
    
    ```cpp
    Complex *p1, *p2;
    p1 = new Complex;
    p2 = new Compex(0,0);
    p->ShowComlex(); // 화살표 연산자를 통해 동적 할당된 객체의 멤버 접근
    delete p2;
    ```
    
    - delete p2를 호출하게 되면 p2가 가리키고 있는 동적 메모리 주소에 대한 데이터를 삭제하는 것이지 p2 자체의 메모리 값이 삭제가 되는 것은 아니다.
    - delete p2 이후 p2가 가리키고 있는 메모리는 이미 해제가 되었기 때문에 다른 곳에서 p2 포인터 변수를 통해 어떠한 작업을 진행하게 된다면 위험하게 될 수가 있다.
    - 따라서 p2를 사용하는 시점이 끝나면 p2에 nullptr을 할당하여 잘못된 메모리에 접근하는 것을 방지할 수 있다.

## 부적절한 객체 생성

- 지역적으로 선언시
    
    ```cpp
    Complex c1;
    c1 = Complex(0, 0); // function "Complex::operator=(const Complex &)" (declared implicitly) cannot be referenced -- it is a deleted functionC/C++(1776)
    ```
    
    - 지역 내에서 c1이라는 변수를 생성하는 것만으로 Complex라는 객체는 생성이 된다.
    - 그런데 이미 객체가 생성된 변수 c1에 새로운 객체를 생성하여 할당하게 되면 에러가 발생하게 된다.
- 생성자에서 다른 생성자 호출?
    
    ```cpp
    Complex::Complex()
    {
    	Complex(0, 0);
    }
    ```