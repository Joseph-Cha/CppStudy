# 8강. 매개변수의 세 가지 형태

## 함수의 매개변수 전달 방식

- 값에 의한 전달(call by value)
    - 매개변수: 일반 변수
    - 실인수의 결과값이 매개변수로 복사됨
- 주소에 의한 전달(call by address)
    - 매개변수: 포인터 변수 이용
    - 실인수의 주소값이 매개변수로 복사됨
- 레퍼런스에 의한 전달(call by reference)
    - 매개변수(?): 레퍼런스 이용
    - 매겨변수가 실인수에 대한 레퍼런스로 정의됨

## 값에 의한 전달(call by value)

- 함수 호출문에 작성된 실인수의 결과값이 매개변수로 복사됨
    - 매개변수를 위해 별도의 메모리가 할당됨
- 매개변수의 값이 바뀌더라도 실인수는 변화 없음

![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.08/1.png)

## 포인터를 이용한 참조에 의한 전달

- 실인수의 주소값이 매개변수로 복사됨
    - 매개변수는 주소값을 통해 실인수 공유
- 매개변수를 통해 실인수를 변경할 수 있음
    - 값추적 연산자 사용

![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.08/2.png)

- 매개변수가 포인터이기 때문에 swap 함수를 호출할 당시 변수의 주소 값(&)을 전달해야 한다.

## 레퍼런스를 이용한 참조에 의한 전달

- 실인수에 대해 레퍼런스를 생성
    - 매개변수를 위한 메모리 공간이 할당되지 않음
        - 따라서 실인수가 복사되지도 않음
    - 레퍼런스를 통해 실인수 공유
- 매개변수를 통해 실인수를 변경할 수 있음
    - 일반변수처럼 사용

![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.08/3.png)

- 매개변수가 레퍼런스이기 때문에 swap 함수를 호출할 당시 변수 값을 그대로 전달하면 된다.
- 하지만 함수 호출 당시 포인터와는 달리 그냥 값을 전달해 주면 되기 때문에 해당 함수가 레퍼런스를 매개변수로 취하는 함수인지 확인하기가 어렵다.

## 포인터 매개변수 vs 레퍼런스 매개변수

- 포인터 매개변수
    - 매개변수를 위한 메모리가 할당됨
    - 포인터에 의한 간접참조 연산 필요
    - 잘못된 포인터 조작에 의한 위험성 존재
- 레퍼런스 매개변수
    - 매개변수를 위한 메모리가 할당되지 않음
    - 포인터 연산이 불필요하므로 보다 안정적
    - 함수 호출 형태 구분이 어려움
        - 값에 의한 함수 호출과 구분 안됨

## 레퍼런스 매개변수를 이용한 함수 호출 특징

- 매개변수를 실인수에 대한 레퍼런스로 선언
    - 실인수가 매개변수로 복사되지 않음
        - 매개변수로 복사되는 크기가 큰 경우 효율적
        - 레퍼런스 매개변수 자체도 메모리 할당 불필요
    - 레퍼런스 매개변수로 실인수 변경 가능
        - 포인터와 같은 효과를 가지면서 간판현 사용, 가독성, 유지보수 용이
        - 2개 이상의 반환 값을 갖는 함수에 유용
    - 기본적으로 실인수에 상수 사용 불가

## const 레퍼런스

```cpp
void fn(const int& ref);
```

- 레퍼런스 ref은 const int
- ref를 통해 실인수 변경 불가

- 매개변수를 통한 변경을 방지
    - 실수/고의로 실인수의 값 변경 방지
- 프로토타입에서 인수변경 불가 확인 가능
- 상수에 대한 참조 가능
- 참고
    
    ```cpp
    void fn(const int* p);
    ```
    
    - 포인터 p가 가리키는 것은 const int
    - p는 바뀔 수 있으나 *p는 변경 불가 → 즉 p의 메모리 값은 변경될 수 있지만 포인터 변수 p가 가지고 있는 주소 값은 변경 불가