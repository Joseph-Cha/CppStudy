# 6강. 포인터 주요 개념 정리

## 포인터(pointer)

- 어떤 다른 값이 저장되어 있는 메모리 주소를 가지고 있는 상수/변수(4byte)
    - int i를 선언하게 되면 물리 메모리의 4바이트 공간을 확보한 후 변수 i의 값을 할당하게 되는데 이때 변수 i의 값이 1000번지부터 1003번지까지 할당되어 있다고 가정하면 1000번지에 대한 주소 값이 변수 i에 맵핑되어 사용이 된다.
    - i = 10을 할당하게 되면 1000번지부터 4바이트 공간에 10이라는 정수 상수 값을 32bit(4byte) 데이터로 코드화 되어 저장된다.
    - 하나의 변수를 선언했을 때 사용하는 자료형이라는 것은 그 변수가 담을 수 있는 데이터 타입을 기술하게 된다. 즉, 몇 바이트 공간이 할당할 것인지 또 할당되어진 공간을 어떤 식으로 코드화 해서 사용할 것인지를 지정해 준다.
    - 마찬가지로 정수형 포인터 변수 int *p를 선언했다고 한다면 p라는 변수도 i라는 변수와 마찬가지로 하나의 변수에 대한 식별자로서 일정한 메모리 공간이 할당되어지고 그 공간에 대한 시작 주소에 직접 맵핑이 되어지는데 여기서  우리 환경에서의 모든 포인터 변수는 기본적으로 4바이트 공간이 할당되어진다(정수형 포인터나 더블형 포인터나 상관 없이  하나의 주소값을 저장하기 위해서 4바이트 공간이 할당된다).
    - 특히 이런 정수형 포인터다라는 것은 하나의 주소를 저장하는데 그 주소에 가보면 정수가 있다는 것을 나타내기 때문에 반드시 이 주소 값은 정수형 변수에 대한 주소값만 집어넣을 수 있게 되는 것입니다.
    - 따라서 일반적으로 포인터 변수는 기존 변수에 대한 주소 연사자를 통해서 어떤 상대적인 주소값으로 초기화 해준다.
    - 즉, int* p = &i 와 같이 초기화가 가능하다. 이는 p라는 변수가 직접 맵핑하고 있는 1004번지에서 1007번지에다가 i의 주소값(1000번지)을 bit열로 코드화 해서 할당하게 된다.
    - 이로써 포인터 변수 p는 1000번라는 값을 가지고 있고 메모리 1000번지를 간접 참조할 수 있게 되어지는 가능성을 가지게 되는 것입니다.

## 기본적인 포인터 연산

- 예시
    
    ```cpp
    int x, y;
    int *p1, *p2;
    
    x = -42;
    y = 163;
    
    p1 = &x;
    p2 = &y;
    
    *p1 = 17;
    *p1 = *p2;
    
    p1 = p2;
    ```
    
    ![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.06/1.png)
    
- 왼쪽과 같이 변수들을 선언했을 때 오른쪽 이미지와 같이 4바이트 씩 메모리 공간을 할당하여 값을 저장할 수 있게 된다.
- x에 -42를 할당하고 y에 163을 할당하면 각 값을 이진 비트로 코드화 하여 앞서 확보한 메모리에 값을 쓰게 된다.
- 이어서 p1과 p2 포인터 변수에 각각 x와 y의 주소 값을 할당하게 되면 각각 1000번지라는 주소 값과 1004번지라는 주소 값을 할당하게 된다.
- 일반 변수와 포인터 변수와의 유일한 차이점은 포인터 변수는 간접 참조 연산을 수행할 수 있다라는 것입니다.
- 간접 참조 연산을 하지 않는 포인터는 정수형 변수와 같다라고 생각할 수 있다.
- 따라서 *p1 = 17이라는 연산을 수행하게 되면 p1의 메모리 값에 17을 저장하는 것이 아니라 p1이 간접 참조하고 있는 x 메모리에 17을 할당하게 된다.
- *p1 = *p2이라는 연산은 p2가 간접 참조하고 있는 y의 메모리 값 즉, 163을 p1이 간접 참조하고 있는 메모리 즉 x의 메모리에 할당한다는 의미이다.
- p1 = p2라는 연산은 p2 메모리에 저장되어 있는 주소 값을 p1에 저장한다는 의미이다.

## 포인터가 사용되는 경우

### 1. 포인터 매개변수

- 함수의 인수로 변수에 대한 주소값이 사용되어진 경우
    - 함수가 2개 이상의 값을 반환해야 할 때
        - 매개 변수를 주소 값을 전달함으로써 여려 매개변수를 전달할 수 있다.
    - 함수 인수로 큰 구조의 구조체 변수가 사용될 때
        - 구조체를 그냥 매개변수로 전달을 하면 값이 복사가 되기 때문에 주소로 전달하는 것이 좀더 메모리를 절약할 수 있고 속도도 더 빨라질 수 있다.
- 함수의 인수로 배열 이름이 사용되어진 경우(배열의 이름 전달 → 배열의 주소 값 전달)
    - 배열의 요소들을 함수 내에서 접근하고자 할 때

### 2. 주소를 반환하는 함수

- 어떤 함수 안에 지역적으로 포인터를 선언한 후 사용하는 경우에는 거의 해당 함수가 반환하기 때문에 반환되어 지는 주소를 전달 받기 위한 목적으로 포인터 매개변수를 지역적으로 사용하는 경우가 있을 수 있다.
- ex) c언어 → malloc, strcpy
- 어떤 함수가 주소를 반환한다면 해당 주는 반드시 함수가 끝난 다음에도 유효한 주소 공간이어야 하기 때문에 대부분의 경우 동적 할당된 주소 값을 호출 쪽으로 반환하는 경우에 많이 사용이 된다.

## 포인터에 의한 인수 전달 - 메모리 측면

```cpp
main()
	int x;
	x = 10;
	SetToZero(&x);

-------------------

void SetToSero(int* var)
	*var = 0;

```

![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.06/2.png)

## 포인터와 배열

- 배열의 요소 타입을 base 타입으로 갖는 포인터로 배열의 요소를 가리킬 수 있음
- 포인터가 가리키는 곳 인접한 곳에 같은 자료형이 있다 가정하여 접근 가능
    - 포인터의 산술연산
        - 전제
            - p: 배열 array에서 첫 요소에 대한 포인터
            - k: 정수
        - p + k는 &array[k] 이다.
            - 포인터가 가리키는 자료의 크기 단위로 포인터 값이 증감

## 포인터 산술

```cpp
double list[3];
double *p;

list[0] = 1.0;
list[1] = 1.1;
list[2] = 1.2;

p = list;
```

![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.06/3.png)

- 포인터가 배열을 가리키려고 한다면 요소 타입 뿐만 아니라 요소에 대한 갯수 정보도 가지고 있어야 하는데 여기서 포인터 p는 이러한 정보를 가지고 있지는 못한다.
- 따라서 배열을 가리킬 수 있는 포인터 즉, 배열 포인터가 따로 존재한다.
    
    ```cpp
    char (*arr)[3];
    char tmp1[3] = { 'b', 'l', 'o' };
    arr = &tmp1; //arr은 tmp1의 주소를 가리킵니다.
    
    for (int i = 0; i < (int)sizeof(*arr); i++) {
        printf("%c", (*arr)[i]); // blo를 한글자씩 출력
    }
    ```
    
- p를 마치 배열처럼(p[1] 처럼) 사용이 가능하다.
- 배열의 이름은 결국 포인터 상수이다.