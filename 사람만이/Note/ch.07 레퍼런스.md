# 7강. 레퍼런스

- 포인터가 유용한 것은 사실이다.
- 변수가 갖는 지역적인 한계를 넘어설 수 있고 동적 할당된 메모리를 접근할 수 있도록 해준다.
- 다만, 포인터는 다른 공간의 주소를 갖고 있는 변수이다 보니 간접 참조 연산(*)과 함께 사용했는지 여부에 따라서 포인터 변수의 값이 바뀔 수 있고 대상이 되어지는 즉 간접참고 하고 있는 영역의 내용이 바뀔 수도 있어 포인터에 익숙하지 않은 프로그래머에게는 다소 혼란스러운 부분이다.
- 특히 프로그램 수행 중 비정상적인 종료를 야기시키는 대표적인 원인이기도 하다.
- 따라서 C++에서는 메모리에 다른 부분을 접근할 수 있는 또 다른 방법으로써 레퍼런스라는 문법을 제공해 주고 있다.

## 레퍼런스(Reference)

- 기존 l-value에 대해 또 다른 이름을 정의
    - 기존 l-value에 대한 ‘별명 설정’ 효과
    - 반드시 선언과 동시에 초기화
- 예시
    
    ```cpp
    data_type& ref_var = variable_name;
    ```
    
    - int a;
    - int& r = a;
    - 기존에는 a로 접근할 수 있었던 메모리 공간에 대해서(또는 변수에 대해서) r이라는 이름으로 접근할 수 있도록 추가의 이름을 설정하는 것이다.
    - 레퍼런스를 사용하기 위해서는 사용하고자 하는 변수의 별명에 대한 타입과 “&”을 붙여서 사용하게 된다.
    - 이렇게 하면 변수를 사용하는 문장이 아니라 기존에 있던 데이터에 대한 별명을 선언하는 구문이다라는 것을 컴파일러에게 명료하게 나타내주게 된다.
    - 기존에 a라는 변수의 이름에 새로운 r이라는 이름이 붙었다라고 이해하자.
- 참고) 포인터 변수
    - 다른 변수의 “주소값을 내용”으로 갖는 변수
    - base_type* pointer_var;

## 포인터 vs 레퍼런스

```cpp
int a = 10; // 1000 ~ 1003번지의 메모리 영역을 확보(4byte 공간)한 다음 10을 할당
int* p;     // 1004 ~ 1007번지까지의 메모리 영역을 확보
p = &a;     // 1004 ~ 1007번지 메모리 공간에 1000번지 주소 값(32비트)을 할당

int& r = a; // 1000번지를 가리키는 이름이 a라는 이름과 더불어서 r이라는 이름이 하나 더 추가되었다.
r = 20;     // 1000번지에 대한 내용을 20으로 바꿀 수 있다(참조 연산자 필요 x)
```

![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.07/1.png)

- r은 간접 참조 연산자의 도움 없이 또 레퍼런스를 적절한 값으로 초기화하기 위해서 별도의 구문을 두는 것 없이 그저 레퍼런스를 선언하는 과정을 통해서 우리는 1000번지에 접근할 수 있는 또 다른 이름 r을 하나 더 얻어낼 수 있게 된 것이다.
- 레퍼런스 변수는 포인터 변수와 마찬가지로 같은 함수 내에 있는 다른 변수를 참조하기보다는 보통 함수의 매개변수로 사용되어짐으로써 다른 함수에서 정의되어진 변수를 좀더 간단하게 참조할 수 있도록 하는데 즐겨 사용됩니다.
- 즉, 기존의 포인터 매개변수가 사용되어졌던 부분들에 많은 부분들을 레퍼런스가 대체해 나갈 수 있게 되어진다.

## 레퍼런스 vs  일반 변수

- 레퍼런스는 변수가 아니다.
    - 레퍼런스를 위해 별도의 메모리 공간을 할당하지 않기 때문
        - 참조 대상을 복사 받지도 않음
    - 지정된 레퍼런스의 참조 대상 변경 불가
        - 참조 대상을 변경해야 한다면 포인터 사용
        - 포인터는 하나의 주소값을 담고 있는 변수이기 때문에 얼마든지 새로운 주소값을 담음으로써 다른 공간들을 참조할 수 있지만 레퍼런스는 한번 설정되어지면 그 레퍼런스가 유효한 영역 동안에서는 지속적으로 그 값만 참조할 수밖에 없다라는 제언이 있습니다.
        - 다만, 레퍼런스는 포인터와 달리 하나의 별명으로서 그 레퍼런스가 참조하고자 하는 영역을 별도의 연산자 없이 마치 기존의 변수 이름처럼 그대로 사용할 수 있기 때문에 포인터 보다 훨씬 더 간단하게 사용할 수 있다는 장점을 가지고 있다.
- 그러나 레퍼런스는 그것이 참조하는 일반 변수처럼 사용 가능

## 레퍼런스 vs 일반 변수 이름

- 생성되는 방법만 차이
    - 변수 선엄문에 의해서는 메모리 할당이 일어나지만 레퍼런스 선언으로는 그저 이름만 새롭게 할당되어질 뿐 추가의 메모리가 할당되어지지 않는데 그렇게 만들어진 변수 이름이나 혹은 레퍼런스는 생성된 후에는 똑같은 의미로 똑같은 효력을 지니는 형태로 사용되어질 수 있다.
- 왼쪽의 경우나 오른쪽의 경우나 결국 모두 20이라는 메모리 공간에 접근하게 된다.
    
    ![Untitled](/resources/%EC%82%AC%EB%9E%8C%EB%A7%8C%EC%9D%B4/ch.07/2.png)
    

## 레퍼런스의 특징 - 참조 대상

- 선언과 동시에 참조 대상 지정
    - 참조 대상이 지정되지 않으면 컴파일 오류
    - 매개변수/반환형으로 사용될 경우는 예외
        - 실인수/반환값이 참조 대상으로 자동 지정되므로
- 기본적으로 상수에 대한 레퍼런스는 불가
- 포인터 변수에 대한 참조 가능
    - NULL에 대한 참조 X
        
        ```cpp
        // 모두 컴파일 오류!
        int& r1; // 선언과 동시에 참조 대상 미지정
        int& r2 = 10; // 상수에 대한 레퍼런스는 불가
        int& r3 = NULL // NULL에 대한 참조 x
        ```