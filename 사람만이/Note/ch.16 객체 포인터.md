# 16강. 객체 포인터

## 객체 포인터

- 다른 객체의 주소를 갖고 있는 포인터
    - base type이 class type인 포인터
    
    ```cpp
    클래스명* 포인터_변수명;
    ```
    
- 반드시 임의 객체의 주소값으로 포인터 변수 초기화 필요!
    - 포인터 자체만을 위한 메모리만 확보되기 때문
- 객체 포인터로 멤버 참조 → 연산자 사용
    - (*x).Show(); → 연산자의 우선순위상 .이 더 높기 때문에 ()를 꼭 쳐줘야 한다.
    - x→Show(); → 조금 더 간단히 x가 가리키고 있는 객체를 접근할 수 있는 방법이다.

<aside>
💡 포인터에 타입이 있는 이유
해당 포인터 변수가 가리키고 있는 메모리에 있는 데이터의 타입을 알려주기 위함.
즉, 포인터 변수가 가리키고 있는 메모리 주소에 있는 데이터의 타입이 곧 포인터 변수의 타입이다.
해당 포인터 변수는 반드시 그 포인터 변수의 타입의 메모리 주소만을 담을 수 있다.
따라서 포인터 변수는 반드시 그 선언된 타입의 주소 값으로 초기화를 해줘야 한다.

</aside>

## 객체 포인터로 멤버 접근

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a0741aa1-660a-4ab6-b485-884ed86a7cbb/Untitled.png)

## this 포인터

- 멤버 함수 호출 시, 수행되는 멤버 함수에게 자동으로 전달되는 호출 객체 자신에 대한 포인터
    - 멤버 함수 안에서 자동 정의되는 매개변수
- 멤버 함수 안에서 그 자신의 다른 멤버들을 조작하고자 할 때 사용
    - 내부적으로 전달되는 포인터
        - 멤버 접근 시 컴파일러에 의해 기입됨(묵시적 사용)
    - 명시적으로 사용해도 무방
        - 보통, 데이터 멤버와 매개 변수 구분 위해 사용

## instance 멤버 변수와 멤버 함수

- 하나의 객체를 위한 인스턴스 멤버 변수들은 스택 영역에 메모리를 할당 받게 되어집니다.
- 각각의 객체에 포홤되어진 인스턴스 멤버 변수는 각 객체의 고유한 상태 정보들을 저장할 필요가 있기 때문에 각 객체마다 별도의 저장 공간들을 확보 받는 일들이 필요하다.
- 하나의 객체가 가지고 있는 멤버 함수라는 것을 가만히 생각해 보면 현재 각각의 컴플랙스 객체가 동작하는 멤버 함수들에 대한 코드들은 서로 동일한 행위를 수행하면 된다.
- 더불어서 각 멤버 함수가 처리할 내용들은 프로그램 코드상에서 결정되어져 있기 때문에 굳이 각각의 스택 영역의 별도로 객체마다 할당을 해 주어서 수정을 해야할지 여부를 판별하도록 할 필요가 없다.
- 따라서 원칙적으로 본다라고 하면 하나의 객체가 생성되었을 때 그 객체가 가지고 있는 인스턴스 멤버 함수 같은 경우는 코드 영역에 그냥 남아 있고 다만 현재 x라는 객체 이름을 통해서 해당하는 멤버에 접근할 수 있도록 연결되어 진다라고 개념적으로 생각해 보자.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/44b7771a-b5eb-4cef-b1be-95502769cca9/Untitled.png)

- 어떤 하나의 클래스의 특정 멤버 함수가 ShowComplex 한다는 행위 자체를 본다 한다면 달라질 것은 없다.
- 하지만 그 ShowComplex 함수가 호출되어질 때 참조할 데이터 멤버가 어떤 객체이냐라는 것들은 매 순간마다 달라질 수 밖에 없다.
- 이처럼 어떤 특정 객체에 대해서 멤버함수를 호출할 때 현재 멤버 함수로 호출하는 객체에 대한 주소 값이 해당하는 함수의 첫번째 매개변수 즉 this라는 포인터로 내부적으로 전달되어지는 일이 일어난다.

## this 포인터의 “내부 구현”

```cpp
#include "Complex.h"

int main(void)
{
	Complex x(10, 20);
	x.ShowComplex(/*&x*/);
	return 0;
}

// Complex.cpp
void Complex::ShowComplex(/*Complex* this*/)
{
	cout << /*this->*/real << "+" << /*this->*/image << endl;
}
```

- 컴파일 타임 때 ShowComplex의 첫 번째 매개변수로 `Complex* this` 를 전달할 수 있도록 수정하게 된다.
- 따라서 ShowComplex 함수 구현부에서 Complex 객체의 멤버 변수를 접근할 때는 “this→”가 컴파일 타임 때 붙게 된다.

## this 포인터를 이용한 멤버 필드 접근

- 일반적인 경우 this 포인터를 사용하지 않아도 무방
- 보통 매개변수와 멤버변수 이름이 같은 경우 명시적으로 구분 위해 사용

```cpp
void Complex::SetComplex(double real, double image)
{
	this->real = real;
	this->image = image;
}
```

- 멤버 변수와 매개변수의 이름이 동일할 때 어떤 함수 내에서 이름이 같은 서로 다른 지역에서 선언되어지는 변수들이 존재할 수는 있다.
- 이 경우 나중에 만들어진 변수가 더 우선시에서 표현되어지는데 멤버 변수는 객체가 생성되어질 때 만들어지고 매개변수는 그 객체에 대해서 이 멤버함수가 호출되었을 때 만들어지니깐 일반적으로 함수 정의 안에서 멤버 변수와 동일한 매개변수를 사용하면 오로지 매개변수에만 접근을 하게 된다.