## 6.11 메모리 동적 할당 new와 delete

``` C++
#include <iostream>
#include <cstddef>

using namespace std;

// 우리가 메모리가 할당되는 것은 3가지
// 정적 메모리 할당 : 전역 변수, static 변수와 같이 프로그램이 끝날 때까지 계속 남아 있음
// 자동 메모리 할당 : 변수, 정적 배열
// 동적 메모리 할당 : 포인터와 관련해서 까다로움

int main()
{
    // int array[10000000]; // stack의 용량은 작다 
    // 반대로 힙의 메모리는 크다
    
    int var;
    // int 타입의 변수를 동적으로 할당
    int *ptr = new int { 7 }; // os로부터 받아온 4바이트 주소를 받아옴
    *ptr = 7;

    delete ptr; 

    cout << "After delete" << endl;
    cout << ptr << endl; // 주소는 그래도 남아 있음
    cout << *ptr << endl; // 하지만 쓰레기 값이 들어가 있음 => 이게 가장 큰 문제

    // 할당 받은 메모리를 os에게 돌려줘야 한다.
    // 빅데이터를 다루면 컴퓨터 한대로 감당할 수 없는 데이터 양을 사용해야 한다.
    // 메모리에 한번에 올라가지 않을 수가 있다.
    // 일부 데이터를 가지고 작업을 하고 OS에 돌려줬다가 
    // 다시 메모리를 받아서 데이터를 가지고 와야 할 수도 있다.

    // 여러 프로그램들이 동시에 많은 메모리를 사용하고 싶다고 한다면
    // 동시에 프로그램을 돌릴 수 없게 된다.
    // => 먼저 가장 급한 프로그램한테 메모리를 사용할 수 있도록 해주고
    // 해당 메모리를 돌려 받고 다음 프로그램이 사용할 수 있도록 해준다.
    // 이렇게 왔다 갔다 하면서 관리를 하면 조금 더 효율적이다.

    // 메로리 해제
    // 이렇게 메모리를 해제하지 않는다면
    // OS는 해당 프로그램이 이 메모리를 사용하고 있는 것을 기억하고 있다.
    // 프로그램이 종료 됨과 동시에 할당된 메모리를 가져감
    // delete를 하면 사전에 메모리를 반납함
    // delete ptr; 

    // 이와 같은 문제를 방지하는 방법
    // nullptr을 넣는 이유는 포인터의 주소가 아무런 의미가 없음을 안내
    delete ptr;
    ptr = nullptr;
    if (ptr != nullptr) // 이렇게 null이 아닐 때 특정 작업을 함
    {
        cout << ptr << endl;
        cout << *ptr << endl;
    }

    // 스마트 포인터를 배우면 굳이 위 과정이 필요 없다.

    // 가끔 메모리를 할당 받으려고 하는 데 받지 못하는 경우
    // => 특정 프로그램이 모든 메모리를 사용하고 있을 때
    // 이때 프로그램이 죽도록 하는 방법이 있고
    // 메모리가 반납 됐을 때까지 기다리는 방법이 있다.
    // 이렇게 하면 오류를 발생시키지 않고 밀어 붙이게 된다. => 향후 예외 처리에서 더 다룸
    int *ptr_nothrow = new (nothrow) int { 7 }; // => error가 발생되면 nullptr이 할당됨
    if (ptr_nothrow)
    {
        // do something
    }
    else
    {
        cout << "Could not allocate memory" << endl;
    }

    // 흔히 할 수 있는 실수
    int *ptr2 = ptr;
    delete ptr;
    ptr = nullptr;
    // *ptr2 => 오류 발생
    // ptr2도 nullptr로 초기화를 시켜줘야 하는 데 까먹는 경우가 많이 있다.
    // 위와 같은 실수 방지
    // 스마트 포인터를 사용

    // 메모리 누수 memory leak
    // 계속 메모리를 계속 생성만 했을 때 발생
    while (true)
    {
        // ptr은 사라지지만 new로 생성된 값은 메모리에 살아있다.
        int *ptr = new int;
        cout << ptr << endl;
    }    
    // 메모리 누수를 확인 할 수 있는 방법
    // 1. 할당 받는 메모리가 클 경우 
    // => 메모리 사용량을 확인해서 과도하게 많이 사용 중인 것이 확인 

    // new와 delete은 느린 연산이다.
    // 왜냐하면 os를 통해 메모리를 할당 받고 돌려주는 작업을 하기 때문이다.
    // new와 delete를 최대한 적게 사용하는 것이 좋다.
    return 0;
}
```