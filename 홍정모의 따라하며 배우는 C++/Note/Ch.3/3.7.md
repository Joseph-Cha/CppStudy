``` C++
#include <iostream>
#include <cmath>

int main()
{
    using namespace std;
    
    /*
    10진법
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10 = 10^1 + 0 자리수가 늘고 0부터 다시 시작
    12 = 10^1 + 1 
    13 = 10^1 + 2 
    ...
    337 = 10^2 * 3 + 10^1 * 3 + 10^0 * 7
    */

    /*
    2진수
    0       =
    1       
    10      = 2^1 * 1 + 2^0 * 0 = 2
    11      = 2^1 * 1 + 2^0 * 1 = 3
    100     = 2^2 * 1 + 2^1 * 0 + 2^0 * 0 = 4
    101     = 2^2 * 1 + 2^1 * 0 + 2^0 * 1 = 5
    */

    /*
    2진수 => 10진수
    int 4bytes = 32bits = 2진수 자리수가 32개
    일단 예제에서는 8bit 1byte로 
    
    0101 1110 : 2진수 
    7654 3210 : 자리수
    94 : 10진수

    2^7 * 0 + 2^6 *1 + 2^5 * 0 + 2^4 * 1 + 2^3 * 1 + 2^2 * 1 + 2^1 *1 2^0 * 0 
    0 + 64 + 0 + 16 + 8 + 4 + 2 + 0 =  94 
    */
    
    /*
    10진수 => 2진수
    148

    1st method
    148 / 2 = 74 r : 0 (r : remainder, 나머지)
    74 / 2 = 37 r : 0
    37 / 2 = 18 r : 1
    18 / 2 = 9 r : 0
    9 / 2 = 4 r : 1
    4 / 2 = 2 r = 0
    2 / 2 = 1 r = 0
    1 / 2 = 0 r = 1

    1001 0100

    2nd method
    1 2 4 8 16 32 64 128 256 512
    148보다 작거나 같은 값? : 128

    148 >= 128 -> 128 = 2^7,        8번째 자리가 1
    148 - 128 = 20, 20 >= 64 ? No,  7번째 자리가 0
                    20 >= 32 ? No,  6번째 자리가 0
                    20 >= 16 ? Yes, 5번째 자리가 1
    20 - 16         4  >= 8  ? No,  4번째 자리가 0
                    4  >= 4  ? Yes, 3번째 자리가 1
    4 - 4 = 0,                      종료

    1001 0100
    */

    /*
    2진수 더하기
    0110 = 6
   +0111 = 7
   ----------
    1101 = 13
    */

    /*
    -5 
    0000 0101
    보수 complement(거꾸로)
    1111 1010
    1111 1011 : +1을 더함 -> -5
    1을 더하는 이유
    2가지 숫자로 표현될 수 있기 때문에 이를 방지하기 위함

    0000 0000 : 0
    1111 1111 : 보수를 취함 -> 이렇게 되면 0의 음수를 표현하는 방식이 두가지가 됨
    0000 0000 : 그래서 1을 더해서 음의 정수로서의 0의 값을 양의 정수로서 0의 값과 동일하게 만들어줌
    결국 -0과 0의 결과를 같게 하기 위함
    그래서 음수로 바꿀 때 +1을 해줌

    signed int의 경우 가장 앞자리를 +, - 구분을 위해 사용함
    */

    /*
    1001 1110 => signed int (가장 앞자리가 1이기 때문에 음수이다)
    0110 0001 => 보수
    0110 0010 => +1
    98 => 10진수로 바꿈
    -98 => 음수로 전환
    */

    /*
    98 / 2 = 49, r0
    49 / 2 = 24, r1
    24 / 2 = 12, r0
    12 / 2 = 6,  r0
    6  / 2 = 3,  r0
    3  / 2 = 1,  r1
    1  / 2 = 0,  r1
    0110 0010 => 98의 2진수
    1001 1101 => 보수
    1001 1110 => -98의 2진수 +1 
    */

    /*
    signed vs unsigned
    1001 1110

    * signed      
    : 2^7 * 1 + 2^4 * 1 + 2^3 * 1 + 2^2 * 1 + 2^1 * 1 
    : 128 + 16 + 8 + 4 + 2
    : 158

    * unsigned    
    : -98

    signed와 unsigned의 숫자 차이가 매우 크다.
    */

    // 실수 변환을 하는 방식을 찾아보자
    
    return 0;
}

```